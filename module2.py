# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17tHS_CK4FezFWhp-LY0VAmb_4JP8Lveg
"""

import os
import numpy as np
import cv2
import matplotlib.pyplot as plt

def gaussian_kernel(k: int, sigma: float) -> np.ndarray:
    """Create a normalized kxk Gaussian kernel."""
    ax = np.arange(-(k // 2), k // 2 + 1)
    xx, yy = np.meshgrid(ax, ax)
    kernel = np.exp(-(xx**2 + yy**2) / (2 * sigma**2))
    kernel = kernel / np.sum(kernel)
    return kernel

def spatial_blur(img: np.ndarray, kernel: np.ndarray) -> np.ndarray:
    """
    Spatial-domain blur using convolution (filter2D).
    BORDER_CONSTANT makes the operation closer to FFT circular conv after padding choices.
    """
    out = cv2.filter2D(img, ddepth=-1, kernel=kernel, borderType=cv2.BORDER_CONSTANT)
    return out

def fourier_blur(img: np.ndarray, kernel: np.ndarray) -> np.ndarray:
    """
    Frequency-domain blur:
      1) pad kernel to image size
      2) ifftshift kernel so its center is at (0,0)
      3) multiply FFTs
      4) inverse FFT
    """
    M, N = img.shape

    # Pad kernel to image size
    H = np.zeros((M, N), dtype=np.float64)
    kM, kN = kernel.shape
    H[:kM, :kN] = kernel

    # Shift kernel center to (0,0) for correct frequency response
    H = np.fft.ifftshift(H)

    # FFTs
    F = np.fft.fft2(img)
    Hf = np.fft.fft2(H)

    # Multiply in frequency domain
    G = F * Hf

    # Inverse FFT back to spatial
    g = np.fft.ifft2(G)
    g = np.real(g)

    return g

def metrics(a: np.ndarray, b: np.ndarray) -> dict:
    """Compute error metrics between two images."""
    diff = a - b
    mae = float(np.mean(np.abs(diff)))
    mse = float(np.mean(diff**2))
    max_abs = float(np.max(np.abs(diff)))
    return {"MAE": mae, "MSE": mse, "MaxAbs": max_abs}

def main():
    # --------- Config ---------
    input_path = "/input.png"     # put your image here
    out_dir = "outputs"
    os.makedirs(out_dir, exist_ok=True)

    k = 21            # kernel size (odd)
    sigma = 5.0       # gaussian sigma
    # --------------------------

    # Load image as grayscale float64
    img_bgr = cv2.imread(input_path, cv2.IMREAD_COLOR)
    if img_bgr is None:
        raise FileNotFoundError(f"Could not read {input}. Put an image named input.jpg in repo root.")
    img = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY).astype(np.float64)

    # Build kernel
    kernel = gaussian_kernel(k, sigma)

    # Spatial blur
    spatial = spatial_blur(img, kernel)

    # Fourier blur
    fft_blurred = fourier_blur(img, kernel)

    # IMPORTANT:
    # Spatial filtering with BORDER_CONSTANT is not identical to circular convolution.
    # To compare fairly, we focus on interior region where boundary effects are minimal.
    pad = k // 2
    interior_spatial = spatial[pad:-pad, pad:-pad]
    interior_fft = fft_blurred[pad:-pad, pad:-pad]

    # Metrics
    m_all = metrics(spatial, fft_blurred)
    m_interior = metrics(interior_spatial, interior_fft)

    print("\n=== Error Metrics (Spatial vs Fourier) ===")
    print("Full image (includes boundary differences):", m_all)
    print("Interior region (recommended equivalence check):", m_interior)

    # Difference image (scaled for visualization)
    diff = spatial - fft_blurred
    diff_vis = np.abs(diff)
    diff_vis = diff_vis / (diff_vis.max() + 1e-12)

    # Save images
    def save_gray(path, arr):
        arr8 = np.clip(arr, 0, 255).astype(np.uint8)
        cv2.imwrite(path, arr8)

    save_gray(os.path.join(out_dir, "01_original_gray.png"), img)
    save_gray(os.path.join(out_dir, "02_spatial_blur.png"), spatial)
    save_gray(os.path.join(out_dir, "03_fourier_blur.png"), fft_blurred)
    save_gray(os.path.join(out_dir, "04_abs_diff.png"), diff_vis * 255.0)

    # Plot for demo + PDF
    plt.figure(figsize=(12, 8))
    plt.subplot(2, 2, 1); plt.imshow(img, cmap="gray"); plt.title("Original"); plt.axis("off")
    plt.subplot(2, 2, 2); plt.imshow(spatial, cmap="gray"); plt.title("Spatial Convolution Blur"); plt.axis("off")
    plt.subplot(2, 2, 3); plt.imshow(fft_blurred, cmap="gray"); plt.title("Fourier Multiplication Blur"); plt.axis("off")
    plt.subplot(2, 2, 4); plt.imshow(diff_vis, cmap="gray"); plt.title("Abs Difference (normalized)"); plt.axis("off")
    plt.tight_layout()

    fig_path = os.path.join(out_dir, "comparison_figure.png")
    plt.savefig(fig_path, dpi=200)
    plt.show()

    # Also save a short text summary for your PDF
    with open(os.path.join(out_dir, "metrics.txt"), "w") as f:
        f.write("=== Error Metrics (Spatial vs Fourier) ===\n")
        f.write(f"Kernel: Gaussian k={k}, sigma={sigma}\n\n")
        f.write("Full image (includes boundary differences):\n")
        f.write(str(m_all) + "\n\n")
        f.write("Interior region (recommended equivalence check):\n")
        f.write(str(m_interior) + "\n")

    print(f"\nSaved outputs to: {out_dir}/")
    print("Use outputs/comparison_figure.png and outputs/metrics.txt for your PDF.")

if __name__ == "__main__":
    main()

